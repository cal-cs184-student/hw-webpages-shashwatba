<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
		<div style="text-align: center;">Shashwat Bansal</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-shashwatba/hw3/index.html">https://cal-cs184-student.github.io/hw-webpages-shashwatba/hw3/index.html</a>
		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw3-shashwatban">https://github.com/cal-cs184-student/sp25-hw3-shashwatban</a>
		
		<figure>
			<img src="cornell.png" alt="Cornell Boxes with Bunnies" style="width:70%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Part 1: Ray Generation and Scene Intersection</h2>
		<p>To generate camera rays, I looked at the diagram and thought about the transformations that (x, y) goes under (luckily, I didn't need to draw a diagram). Since x and y are in betweeen 0 and 1 initially, we can subtract 0.5 from both of them and multiply by 2 to have them be in the range [-1, 1] instead. Then we can scale them with the width and height of the camera space as per the boundary vertex values in the diagram. Lastly, we multiply by cWd on the left to transform to world coordinates and normalize by dividing with the norm and also set <code>min_t</code> and <code>max_t</code> as indicated in the spec.</p>
		<p>To generate pixel samples, I followed the steps laid out in the spec where I started by generating <code>ns_aa</code> samples using the <code>gridSampler->getSample()</code> method. Then, I mapped these samples to the pixel space by adding the pixel's top-left corner coordinates to the sample offsets and normalizing by the height and width of the space. This ensured that the samples were distributed uniformly within the pixel. Finally, I storedthe running sum of these samples into <code>(x, y)</code> using <code>SampleBuffer.updatePixel</code>.</p>
		<p>My implementation of ray-triangle intersections was the same as the MÃ¶ller-Trumbore algorithm in the slides. I calculated edges <code>e1</code> and <code>e2</code>, crossproducts <code>s1</code> and <code>s2</code> and the difference of the ray origin and triangle vertex <code>s</code>. Then I calculated the (t, b1, b2) vector, which required me to make sure that all values were within [0, 1]. Lastly, in the <code>intersect()</code> function only, I also updated the <code>t, primitive, bsdf and n</code> variables of the <code>isect</code> of the triangle. To calculate <code>n</code>, I dot-producted the normal vector of the triangle with (b1, b2, 1 - b1 - b2).</p>
		<p>For the ray-sphere intersection, I followed the quadratic equation intersection method in the lecture slides. I had to make a few additional checks to ensure that the discriminant was non-negative and that the t values were within the bounds of the sphere. I also had to calculate the normal vector of the sphere at the intersection point in <code>isect</code> by subtracting the center of the sphere from the intersection point and normalizing it.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t1.1.png" width="400px"/>
				  <figcaption>Spheres</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t1.2.png" width="400px"/>
				  <figcaption>Gems</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t1.3.png" width="400px"/>
				  <figcaption>Banana</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t1.4.png" width="400px"/>
				  <figcaption>Teapot</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Part 2: Bounding Volume Hierarchy</h2>
		<p>For the BVH construction, I first initialized a <code>BVHNode</code> to be the entire bounding box. Then, if <code>max_leaf_size</code> is less than the number of primitives in the bbox, I make it a leaf node. Otherwise if the node contains more primitives than allowed in a leaf, the algorithm chooses a splitting axis based on the extent of the centroid bounding box.  It selects the axis along which the centroids vary the most, then partitions the primitives using the midpoint of the centroids along that axis. This is done using <code>std::partition</code>, which rearranges the primitives such that those with centroids less than the midpoint go to the left and the rest go to the right. If partitioning fails to split (e.g., all centroids fall on one side), it defaults to a balanced split. Finally, the algorithm recursively constructs the left and right child nodes, resulting in a binary BVH tree optimized for spatial queries./p>
		
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
				  <tr>
					<td style="text-align: center;">
					  <img src="t2.1.png" width="400px"/>
					  <figcaption>Max Planck</figcaption>
					</td>
					<td style="text-align: center;">
					  <img src="t2.2.png" width="400px"/>
					  <figcaption>Lucy</figcaption>
					</td>
				  </tr>
				  <tr>
					<td style="text-align: center;">
					  <img src="t2.3.png" width="400px"/>
					  <figcaption>Dragon</figcaption>
					</td>
					<td style="text-align: center;">
					  <img src="t2.4.png" width="400px"/>
					  <figcaption>Blob</figcaption>
					</td>
				  </tr>
				</table>
			</div>
		<p>Rendering times were significantly for these images than without the BVH implementation. For example, Lucy took 1.3 seconds with BVH and 1510.2 seconds without BVH. Dragon took 1.0 seconds with BVH and 1258.9 without. This means the average speedup was around 1335x, wherein the creation time of the BVH is logarithmic alongside the time to traverse it. By avoiding checking unnecessary nodes not in the BVH tree, we save enough time to go from O(n) to O(log(n)) time complexity.</p>
		<h2>Part 3: Direct Illumination</h2>
		<p>I first implemented the <code>f()</code> function in <code>bsdf.cpp</code> where I simply returned <code>reflectance/(2*pi)</code> since our algorithm doesn't depend on the input vectors. Next, in <code>zero_bounce_radiance()</code>, I called the bsdf's <code>get_emission()</code> function.</p>
		<p>For hemisphere lighting, I repeatedly sampled from the bsdf using <code>sample_f()</code> <code>num_samples</code> times. I then account for Lambert's cosine law and compute the cosine theta term between the sample direction and the surface normal (0, 0, 1). Next, I transform the sample into world space coordinates by multiplying with <code>o2w</code>. I keep track of the shadow ray generated in that direction from the surface point. Then, I check for any intersection between the shadow ray and a surface using <code>bvh->intersect</code> and add it as a running sum to <code>L_out</code>, where the light is computed as \( \frac{L * f * cos\theta}{pdf} \). Lastly, we divide by <code>num_samples</code> to produce an average of the samples and return it.</p>
		<p>For importance sampling, the key was realizing that I only need to sample directions which have light sources in them. This time, I perform <code>ns_area_light</code> samples instead for each light in the scene and calling <code>sample_L</code> to sample. Again, I computed the shadow ray from the light source, but made sure to cap it at the distance from the source, or it will overshoot. I then similarly checked for intersection with the BVH, updating the running sum with the same formula. Another thing I did was that I skipped values corresponding to non-positive thetas, as those would be light sources in the wrong direction. Lastly, I averaged the samples as before.</p>
		
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t3.1.png" width="400px"/>
				  <figcaption>Hemisphere Lighting: Bunny with 16 samples per pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t3.2.png" width="400px"/>
				  <figcaption>Hemisphere Lighting: Bunny with 64 samples per pixel</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t3.3.png" width="400px"/>
				  <figcaption>Importance Lighting: Bunny with 16 samples per pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t3.4.png" width="400px"/>
				  <figcaption>Importance Lighting: Bunny with 64 samples per pixel</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="t3.21.png" width="400px"/>
				  <figcaption>Importance Lighting: 1 light ray</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t3.22.png" width="400px"/>
				  <figcaption>Importance Lighting: 4 light ray</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="t3.23.png" width="400px"/>
				  <figcaption>Importance Lighting: 8 light ray</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="t3.24.png" width="400px"/>
				  <figcaption>Importance Lighting: 16 light ray</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<p>Overall, importance sampling significantly outperforms uniform hemisphere sampling in terms of visual quality and efficiency. Hemisphere sampling sends rays in arbitrary directions, which results in many ineffective samples and leads to high-frequency noise, particularly in scenes with small or occluded light sources. Importance sampling addresses this by directing rays toward known light sources, ensuring most samples are productive. This results in brighter, smoother images with accurate soft shadows, even with fewer samples. The improvement is most notable in less well-lit areas like wall corners where uniform sampling fails to capture the darkness appropriately.</p>
		<h2>Part 4: Global Illumination</h2>
		<p>In contrast to direct lighting, indirect illumination comes from the light bouncing between non-emitting surfaces in the scene. I implemented global illumination using recursive ray tracing in the <code>at_least_one_bounce_radiance()</code> function. I started by computing the local coordinate frame at the intersection point and transforming the outgoing ray direction into local space. Then, I computed the one-bounce radiance, essentially the direct lighting at that point, either if it was the first bounce or if we were set to accumulate bounces. This ensured that at least the primary surface hit by the camera would receive lighting directly from the light sources.</p>
		<p>To simulate further bounces, I used BSDF sampling to generate a new ray direction and spawn a secondary ray from the hit point. I applied Russian roulette with a 35% termination probability to avoid infinite recursion and improve performance, while still keeping the estimator unbiased. If the new ray intersected another object, I recursively called the same function to calculate its radiance contribution. I then scaled the returned value by the BSDF, cosine term, and PDF (similar to the previous part), adjusting for the Russian roulette probability with continuation probability \( q = 1 - p \) as the denominator in the case the algorithm continues.</p>
		
		<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
						  <img src="t4.1.png" width="400px"/>
						  <figcaption>Bunny with Global Illumination</figcaption>
						</td>
						<td style="text-align: center;">
						  <img src="t4.2.png" width="400px"/>
						  <figcaption>Dragon with Global Illumination</figcaption>
						</td>
					  </tr>
					  <tr>
						<td style="text-align: center;">
						  <img src="t4.3.png" width="400px"/>
						  <figcaption>Bunny with Direct Illumination Only</figcaption>
						</td>
						<td style="text-align: center;">
						  <img src="t4.4.png" width="400px"/>
						  <figcaption>Bunny with Indirect Illumination Only</figcaption>
						</td>
					  </tr>
				</table>
			</div>
			<p>As evident, the bunny with indirect illumination is a lot less well lit than the direct illumination bunny, because it only captures light that has bounced off other surfaces, not the direct light coming straight from the light source. The Global bunny is the brightest of them all, as expected.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
				  <tr>
					<td style="text-align: center;">
					  <img src="a.png" width="400px"/>
					  <figcaption>Bunny: No Accumulation, 0 max-ray-depth</figcaption>
					</td>
					<td style="text-align: center;">
					  <img src="b.png" width="400px"/>
					  <figcaption>Bunny: With Accumulation, 0 max-ray-depth</figcaption>
					</td>
				  </tr>
				  <tr>
					<td style="text-align: center;">
					  <img src="d.png" width="400px"/>
					  <figcaption>Bunny: No Accumulation, 1 max-ray-depth</figcaption>
					</td>
					<td style="text-align: center;">
					  <img src="e.png" width="400px"/>
					  <figcaption>Bunny: With Accumulation, 1 max-ray-depth</figcaption>
					</td>
				  </tr>
				  <tr>
					<td style="text-align: center;">
					  <img src="g.png" width="400px"/>
					  <figcaption>Bunny: No Accumulation, 2 max-ray-depth</figcaption>
					</td>
					<td style="text-align: center;">
					  <img src="h.png" width="400px"/>
					  <figcaption>Bunny: With Accumulation, 2 max-ray-depth</figcaption>
					</td>
				  </tr>
				  <tr>
					<td style="text-align: center;">
					  <img src="j.png" width="400px"/>
					  <figcaption>Bunny: No Accumulation, 3 max-ray-depth</figcaption>
					</td>
					<td style="text-align: center;">
					  <img src="k.png" width="400px"/>
					  <figcaption>Bunny: With Accumulation, 3 max-ray-depth</figcaption>
					</td>
				  </tr>
				  <tr>
					<td style="text-align: center;">
					  <img src="m.png" width="400px"/>
					  <figcaption>Bunny: No Accumulation, 4 max-ray-depth</figcaption>
					</td>
					<td style="text-align: center;">
					  <img src="n.png" width="400px"/>
					  <figcaption>Bunny: With Accumulation, 4 max-ray-depth</figcaption>
					</td>
				  </tr>
				  <tr>
					<td style="text-align: center;">
					  <img src="p.png" width="400px"/>
					  <figcaption>Bunny: No Accumulation, 5 max-ray-depth</figcaption>
					</td>
					<td style="text-align: center;">
					  <img src="q.png" width="400px"/>
					  <figcaption>Bunny: With Accumulation, 5 max-ray-depth</figcaption>
					</td>
				  </tr>
				</table>
			</div>

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="c.png" width="400px"/>
							<figcaption>Bunny: With Accumulation and Russian Roulette, 0 max-ray-depth</figcaption>
						  </td>
						  <td style="text-align: center;">
							<img src="f.png" width="400px"/>
							<figcaption>Bunny: With Accumulation and Russian Roulette, 1 max-ray-depth</figcaption>
						  </td>
					  </tr>
					  <tr>
						<td style="text-align: center;">
							<img src="i.png" width="400px"/>
							<figcaption>Bunny: With Accumulation and Russian Roulette, 2 max-ray-depth</figcaption>
						  </td>
						  <td style="text-align: center;">
							<img src="l.png" width="400px"/>
							<figcaption>Bunny: With Accumulation and Russian Roulette, 3 max-ray-depth</figcaption>
						  </td>
					  </tr>
					 <tr><td style="text-align: center;">
						<img src="o.png" width="400px"/>
						<figcaption>Bunny: With Accumulation and Russian Roulette, 4 max-ray-depth</figcaption>
					  </td><td style="text-align: center;">
						<img src="r.png" width="400px"/>
						<figcaption>Bunny: With Accumulation and Russian Roulette, 100 max-ray-depth</figcaption>
					  </td></tr>
				</table>
			</div>
			
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
						  <img src="1.png" width="400px"/>
						  <figcaption>Banana with 1 Sample Per Pixel</figcaption>
						</td>
						<td style="text-align: center;">
						  <img src="2.png" width="400px"/>
						  <figcaption>Banana with 2 Samples Per Pixel</figcaption>
						</td>
					  </tr>
					  <tr>
						<td style="text-align: center;">
							<img src="3.png" width="400px"/>
							<figcaption>Banana with 4 Samples Per Pixel</figcaption>
						  </td>
						  <td style="text-align: center;">
							<img src="4.png" width="400px"/>
							<figcaption>Banana with 8 Samples Per Pixel</figcaption>
						  </td>
					  </tr>
					  <tr>
						<td style="text-align: center;">
						  <img src="5.png" width="400px"/>
						  <figcaption>Banana with 16 Samples Per Pixel</figcaption>
						</td>
						<td style="text-align: center;">
						  <img src="6.png" width="400px"/>
						  <figcaption>Banana with 64 Samples Per Pixel</figcaption>
						</td>
					  </tr>
					  <tr>
						<td style="text-align: center;">
						  <img src="7.png" width="400px"/>
						  <figcaption>Banana with 1024 Sample Per Pixel</figcaption>
						</td>
					  </tr>
				</table>
			</div>
		
		<h2>Part 5: Adaptive Sampling</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
	</div>
	</body>
</html>