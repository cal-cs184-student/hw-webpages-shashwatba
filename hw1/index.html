<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Name: Shashwat Bansal</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-shashwatba/hw1/index.html">https://cal-cs184-student.github.io/hw-webpages-shashwatba/hw1/index.html</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw1-shashwat">https://github.com/cal-cs184-student/sp25-hw1-shashwat</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		For my basic implementation, I used the idea from lecture 2 of looping through the raster grid and checking each pixel’s midpoint, using a function called is_inside_triangle which returns true if the pixel needs to be colored and false if not. To ensure that the entire triangle is within the raster grid, I first computed min_x, min_y, max_x and max_y, which are the x and y edges of the triangle computed using the input vertices. If is_inside_triangle returns true, the rasterize_triangle function colors that pixel. To implement the actual is_inside_triangle function, I ran the line equation tests but was running into the issue of clockwise vertex orderings not returning “true”. To fix this, I used an idea from Discussion 2: flip any two vertices to change the winding order from clockwise to anti-clockwise in the case that (x1 - x0) * (y2 - y1) - (x2 - x1) * (y1 - y0) < 0, indicating a negative z-axis as per the right hand rule.
		
		My algorithm is no worse than one that checks each sample within the bounding box of the triangle because that is exactly what my algorithm is. I first get the bounds of the bounding box by using the min and max coordinates of the three vertices. Then, I check each sample within this box using the is_inside_triangle function.
		<figure>
			<img src="t1.png" alt="test4"/>
			<figcaption>Task 1</figcaption>
		</figure>

		<h2>Runtime Comparison Table</h2>
		<table>
			<thead>
				<tr>
					<th>Test Number</th>
					<th>Unoptimized Runtime (s)</th>
					<th>Optimized Runtime (s)</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>test3.svg</td>
					<td>0.015</td>
					<td>0.003</td>
				</tr>
				<tr>
					<td>test4.svg</td>
					<td>0.001</td>
					<td>0.0005</td>
				</tr>
				<tr>
					<td>test5.svg</td>
					<td>0.003</td>
					<td>0.001</td>
				</tr>
				<tr>
					<td>test6.svg</td>
					<td>0.002</td>
					<td>0.0008</td>
				</tr>
			</tbody>
		</table>
	
		Adjustments Made:
		<ul>
			<li>Check the winding number before sampling all the points, and swap vertices as necessary only once.</li>
			<li>Remove the helper function to eliminate unnecessary memory accesses.</li>
			<li>Add 0.5 only twice at the start of the loops.</li>
			<li>Implement incremental triangle traversal.</li>
			<li>Precompute variables like <code>x1 - x0</code> into <code>diff_1</code>, <code>y2 - y1</code> into <code>diff_5</code>, etc., to reduce computations.</li>
		</ul>

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		I supersampled triangles by changing my implementation in rasterize_triangle to sample at a higher rate, i.e. sample sample_rate times within each pixel. I kept track of these sampled subpixels inside the sample_buffer, which is now larger to account for width * height * sample_rate pixels. I did not call fill_pixel here, instead opting to directly modify the sample_buffer inside the quadruple for loops. For the lines and points, I modified the call to fill_pixel so that it knows how to correctly index into the sample_buffer and fill in entire pixels with the same line/point color, doing so by looping through the subpixels of the pixel in double for loops just like in rasterize_triangle. Lastly, when resolving to framebuffer, I averaged the subpixels of each pixel by looping through them and adding them to a color, then dividing by the sample_rate before putting the color in rgb_framebuffer_target.
		
		Supersampling is useful because it allows for anti-aliasing the image, filtering out “jaggies” such as in the triangle corner seen below. By sampling at a higher frequency than the display has enough pixels for, then averaging those pixels, the overall effect is that the image is smoother and more realistic, since edges are blurred rather than being in staircase like patterns. The main part of the rasterization pipeline that was modified was the resolve_to_framebuffer() function, which needed to accommodate a sample_buffer size that is larger than the framebuffer size.

		<h2>Task 3: Transforms</h2>
		I rotated the front half of cube man's left arm and his entire body so that it looks like he is swimming. He is either wearing a golden swimming cap or a scuba diving helmet. His right arm has been rotated to be in a downstroke, while his left is in an upstroke. His legs are elongated because he is wearing diving flippers.
		<figure>
			<img src="swimming.png" alt="Swimming Man" style="width:50%"/>
			<figcaption>Cube Man Swimming</figcaption>
		</figure>
		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates are a way to track points with reference with reference to the sides of a polygon (in this class, specifically only to the sides of a triangle). For example, the image below displays a triangle with each of it’s vertices given a maximum R, G or B value respectively, and all other points in between are colored as per their barycentric coordinates. The higher the alpha value is, the farther the point is to the red vertex, and therefore is less red itself, and similarly for other colors. The sum of alpha, beta and gamma, the three barycentric coordinates, must always be one because the points lie within the triangle, and if any of alpha, beta or gamma are equal to one then we are at the respective vertex (maximum closeness). Also, gamma = 1 - alpha - beta, so we really only need two additional points to compute where our point is.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is the process of sampling the texture in the uv-plane into the xy-plane, going through a non-linear map. Since the map is not linear, bilinear mapping requires a weighted average of the four closest points to the uv coordinate, depending on which part of the pixel the uv coordinate is closest to. In the rasterization function, I needed Barycentric coordinates to interpolate the uv coordinates for each pair of xy coordinates, doing so if the points were inside the triangle. Nearest sampling simply rounds the uv-coordinate to the nearest available integer values and samples it.
		
		As seen below, bilinear sampling produces a smoother rendition of the image regardless of the sampling rate, with less distinct pixels in the streaks of the parrot. There might be a large difference between the two when the xy-plane is much larger than the uv-plane, in which case nearest neighbour will magnify the pixelation in the uv-plane further into the xy-plane, while bilinear will be relatively smooth. This is because 1 texel is mapping to more than 1 pixel, so sampling more than 1 texel as in the bilinear approach provides a more robust algorithm.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>